package iou

use sample.v1.concat;

struct TimestampedAmount {
    amount: Number,
    timestamp: DateTime
};

struct PaymentConfirmation {
    confirmed: Boolean,
    payment: TimestampedAmount
};

function total(entries: List<TimestampedAmount>) -> entries.map(function(p: TimestampedAmount) -> p.amount).sum();

notification RepaymentOccurrence(paymentAmount: Number, remainingAmount: Number) returns Unit;

struct PaymentDetails {
    description: Text,
    forAmount: Number,
    paymentAmount: TimestampedAmount,
    remainingAmount: Number
};

@multinode
notification RepaymentOccurrenceMultiNode(payment: PaymentDetails) returns PaymentConfirmation;

@api
protocol[issuer, payee] Iou(var description: Text, var forAmount: Number) {
    require(forAmount > 0, "Initial amount must be strictly positive");

    initial state unpaid;
    state payment_confirmation_required;
    final state repaid;
    final state forgiven;

    private var payments = listOf<TimestampedAmount>();
    var paymentToBeConfirmed: Optional<TimestampedAmount> = optionalOf<TimestampedAmount>();
    var amountOwed: Number = forAmount;

    function getAmountOwed() returns Number -> forAmount - total(payments);

    @api
    permission[issuer] pay(amount: Number) | unpaid {
        require(amount > 0, "Amount must be strictly positive");
        require(amount <= amountOwed, "Amount may not exceed amount owed");

        paymentToBeConfirmed = optionalOf(
            TimestampedAmount(amount = amount, timestamp = now())
        );
        notify RepaymentOccurrence(amount, amountOwed);
        notify RepaymentOccurrenceMultiNode(PaymentDetails(description, forAmount, paymentToBeConfirmed.getOrFail(), amountOwed - amount));

        become payment_confirmation_required;
    };

    @api
    permission[payee] confirmPayment() | payment_confirmation_required {

        payments = payments.with(paymentToBeConfirmed.getOrFail());
        paymentToBeConfirmed = optionalOf<TimestampedAmount>();
        amountOwed = getAmountOwed();

        if (amountOwed == 0) {
            become repaid;
        } else {
            become unpaid;
        };
    };

    @multinode
    permission[payee] confirmPaymentMultiNode(r: PaymentConfirmation) | payment_confirmation_required {
        if (r.confirmed && paymentToBeConfirmed.getOrFail() == r.payment) {
            payments = payments.with(paymentToBeConfirmed.getOrFail());
            paymentToBeConfirmed = optionalOf<TimestampedAmount>();
            amountOwed = getAmountOwed();

            if (amountOwed == 0) {
                become repaid;
            } else {
                become unpaid;
            };
        } else if (r.confirmed.not()) {
            paymentToBeConfirmed = optionalOf<TimestampedAmount>();
            become unpaid;
        };
    };

    // Dummy permission to illustrate new API endpoint generation
    /*@api
    permission[issuer] doSomething()  {
    };*/

    @api
    permission[payee] forgive() | unpaid {
        become forgiven;
    };

    @api
    permission[payee] getPaymentLog() returns List<Text> {
        return payments.fold(
            listOf<Text>(),
            function(acc: List<Text>, item: TimestampedAmount) returns List<Text> -> {
                return acc.with(getPaymentData(item));
            }
        );
    };

    function getPaymentData(item: TimestampedAmount) returns Text -> {
        return concat(item.timestamp.toText() + " ", item.amount.toText());
    }
}
