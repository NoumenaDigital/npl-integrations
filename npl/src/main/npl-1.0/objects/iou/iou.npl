package objects.iou

struct TimestampedAmount {
    amount: Number,
    timestamp: DateTime
};

function total(entries: List<TimestampedAmount>) -> entries.map(function(p: TimestampedAmount) -> p.amount).sum();

notification RepaymentOccurence(paymentAmount: Number, remainingAmount: Number) returns Unit;

@api
protocol[issuer, payee] Iou(var description: Text, var forAmount: Number) {
    require(forAmount > 0, "Initial amount must be strictly positive");

    initial state unpaid;
    state unpaid_pending_acknowledgement;
    state paid_pending_acknowledgement;
    final state repaid;
    final state forgiven;

    private var payments = listOf<TimestampedAmount>();
    var amountOwned: Number = forAmount;

    function getAmountOwed() returns Number -> forAmount - total(payments);

    @api
    permission[issuer] pay(amount: Number) | unpaid, unpaid_pending_acknowledgement {
        require(amount > 0, "Amount must be strictly positive");
        require(amount <= getAmountOwed(), "Amount may not exceed amount owed");

        var p = TimestampedAmount(amount = amount, timestamp = now());

        payments = payments.with(p);
        amountOwned = getAmountOwed();

        notify RepaymentOccurence(amount, amountOwned);

        if (amountOwned == 0) {
            become paid_pending_acknowledgement;
        } else {
            become unpaid_pending_acknowledgement;
        };
    };

    @api
    permission[payee] acknowledgePayment() | unpaid_pending_acknowledgement {
        become unpaid;
    };

    @api
    permission[payee] confirmRepayment() | paid_pending_acknowledgement {
        become repaid;
    };

    @api
    permission[payee] forgive() | unpaid {
        become forgiven;
    };
}
